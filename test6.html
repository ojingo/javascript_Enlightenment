<!DOCTYPE html>
<html lang="en">
<head>
    <title>Objects don't copy their values they copy their pointers</title>
</head>
<body>

<script>
    // code goes here

    var myObject = {};

    var copyOfMyObject = myObject; /* not copied by value, just the reference is copied */

    myObject.foo = 'bar'; // manipulate the value stored in myObject

    /* Now if we log myObject and copyOfMyObject, they will have a foo property
     because they reference the same object. */

    console.log(myObject, copyOfMyObject);

   /* logs 'Object { foo="bar"} Object { foo="bar"}' */

    var objectFoo = {same: 'same'};
    var objectBar = {same: 'same'};

    /* logs false, JS does not care that they are identical
     and of the same object type */
    console.log(objectFoo === objectBar);

    // how complex objects are measured for equality
    var objectA = {foo: 'bar'};

    var objectB = objectA;

    console.log(objectA === objectB);

    /* logs true because they reference
     the same object */

    var objA = {property: 'value'};
    var pointer1 = objA;
    var pointer2 = pointer1;

    // update the objA.property, and all references (pointer1 and pointer2) are updated
    objA.property = "hello";

    /* logs 'null null null' because objA, pointer1, and pointer2 all reference
     the same object */
    console.log(objA.property, pointer1.property, pointer2.property);



</script>

// html goes here

</body>
</html>